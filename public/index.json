
[{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"\rprint(\u0026#34;Wasssuuuuuuuupppppppppppppppppp\u0026#34;) ","date":"18 March 2025","externalUrl":null,"permalink":"/","section":"Eenosse's Blog","summary":"\rprint(\u0026#34;Wasssuuuuuuuupppppppppppppppppp\u0026#34;) ","title":"Eenosse's Blog","type":"page"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/reverse-engineering/","section":"Tags","summary":"","title":"Reverse Engineering","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Overview # My quick writeup for magicfile challenge from TPCTF 2025.\nMagicfile # We\u0026rsquo;re given a binary file which asks us for a flag. The flag must be 48 characters long.\nIf we type in a random strings like 'a'*48, we will get the output: ASCII text, with no line terminators. So this seems to mimic the file command in Linux. We can look up the source code on Github and compare it with our file.\nThe flag checking seems to be happening in sub_59A0, as it\u0026rsquo;s the only place that uses our input:\n_BYTE *__fastcall sub_59A0( __int64 ms, __int64 input, unsigned __int64 input_len, __int64 input_, __int64 a5, __int64 a6) { if ( !ms ) { return 0LL; } if ( (unsigned int)sub_EBC0(ms, 1, input_len, input_, a5, a6) == 0xFFFFFFFF || (unsigned int)file_buffer(ms, 0xFFFFFFFFLL, 0LL, 0LL, input, input_len) == 0xFFFFFFFF ) { return 0LL; } return file_getbuffer(ms); } This function will compare our input with some defined rules and return the result string. Checking the second function, we can see some strings like [try zmagic %d], [try tar %d], \u0026hellip; Looking this up, it\u0026rsquo;s the function file_buffer. You can find this here.\nThrough debugging, I noticed that if we type in the flag format, it will stop for a while at sub_153B0, which is file_softmagic. This function will check our input using some \u0026ldquo;magic rules\u0026rdquo;. The comparing function is sub_13A70.\nAfter more debugging, the flow seems to be like this:\nIt will iterate through each magic rules by v25 = a2 + 0x178LL * v20;. It will first check that the first letters are TPCTF. If it\u0026rsquo;s correct, it keeps checking, otherwise it will move to other rules (if any). check_flag_magic = magiccheck(v23, a2 + 0x178LL * v20, v29, v30, v31, v32); It will iterate through a sort of list of rules that check each letter. If the rule contains a result string, it will stop and return that string. From the code, it seems like each rule is 0x178 bytes long. So I debugged to find the offset of the rules and dump it out:\nwith open(\u0026#34;magicfile_c970e3503feebf8274571f09d27cdd2f\u0026#34;, \u0026#39;rb\u0026#39;) as f: sus = f.read()[0x212F4:] for i in range(0, len(sus), 0xbc*2): print(sus[i:i+0xbc*2]) So what is the output when we input the right flag? By stringging the binary file, we can find that it\u0026rsquo;s Congratulations! You got the flag. Looking for this in our dump, it\u0026rsquo;s this rule:\nb\u0026#39;+\\x00\\x00\\x00=\\x00\\x01\\x00\\x00\\x00\\x00\\x00/\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd4+\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Congratulations! You got the flag.\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; Notice the } character there. Looking above this, we can see the flag:\n","date":"18 March 2025","externalUrl":null,"permalink":"/posts/tpctf-2025-writeup/","section":"Posts","summary":"Overview # My quick writeup for magicfile challenge from TPCTF 2025.","title":"TPCTF 2025 Writeup - magicfile","type":"posts"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":" Overview # Here are some of the challenges that I solved during PwnMe CTF 2025:\nRev # Back to the past # Using the provided binary and the encrypted file, find a way to retrieve the flag contained in \u0026ldquo;flag.enc\u0026rdquo;. Note that the binary would have been run in May 2024. Note: The flag is in the format PWNME{\u0026hellip;}\nAuthor : Fayred\nFlag format: PWNME{.........................}\nWe are given a binary executable that encrypts the flag file.\neenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ ./backToThePast Usage: ./backToThePast \u0026lt;filename\u0026gt; eenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ echo 1234 \u0026gt; test eenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ ./backToThePast test time : 1740925301 Running the binary, we see that it prints out the current timestamp. So it might use the timestamp for encryption. Let\u0026rsquo;s check that in IDA:\nClick to expand\rint __fastcall main(int argc, const char **argv, const char **envp) { char v3; // cl int v5; // edx char v6; // cl int v7; // edx char v8; // cl int v9; // eax char v10; // cl int v11; // [rsp+1Ch] [rbp-124h] unsigned int v12; // [rsp+20h] [rbp-120h] __int64 v13; // [rsp+28h] [rbp-118h] char v14[264]; // [rsp+30h] [rbp-110h] BYREF unsigned __int64 v15; // [rsp+138h] [rbp-8h] v15 = __readfsqword(0x28u); if ( argc \u0026gt; 1 ) { v12 = time(0LL, argv, envp); printf((unsigned int)\u0026#34;time : %ld\\n\u0026#34;, v12, v5, v6); srand(v12); v13 = fopen64(argv[1], \u0026#34;rb+\u0026#34;); if ( v13 ) { while ( 1 ) { v11 = getc(v13); if ( v11 == 0xFFFFFFFF ) { break; } fseek(v13, 0xFFFFFFFFFFFFFFFFLL, 1LL); v9 = rand(); fputc(v11 ^ (unsigned int)(v9 % 0x7F), v13); } fclose(v13); strcpy(v14, argv[1]); strcat(v14, \u0026#34;.enc\u0026#34;); if ( (unsigned int)rename(argv[1], v14) ) { printf( (unsigned int)\u0026#34;Can\u0026#39;t rename %s filename to %s.enc\u0026#34;, (unsigned int)argv[1], (unsigned int)argv[1], v10); return 1; } else { return 0; } } else { printf((unsigned int)\u0026#34;Can\u0026#39;t open file %s\\n\u0026#34;, (unsigned int)argv[1], v7, v8); return 1; } } else { printf((unsigned int)\u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, (unsigned int)*argv, (_DWORD)envp, v3); return 1; } } Indeed, it uses the timestamp to set seed, then XOR our file with random numbers and write it to a .enc file.\nThings should be easy enough. However, when I tried to write a solve script using libc\u0026rsquo;s random, it didn\u0026rsquo;t give the right result. After debugging, I noticed that the random numbers of the program were different from mine. So something has been changed ðŸ¤”.\nIt turns out the srand and rand functions are not the standard libc functions, but rather custom functions:\n__int64 __fastcall srand(int a1) { __int64 result; // rax result = (unsigned int)(a1 - 1); seed = result; return result; } unsigned __int64 rand() { seed = 0x5851F42D4C957F2DLL * seed + 1; return (unsigned __int64)seed \u0026gt;\u0026gt; 0x21; } The srand function actually sets the seed to be equal to a1 - 1. I\u0026rsquo;m not sure if rand is different from the standard one, but we\u0026rsquo;ll not care about that.\nFrom this, I wrote a quick script to solve the challenge. Given that the challenge\u0026rsquo;s description said the binary would have been run in May 2024, I bruteforced the timestamp from May to June:\ndata = open(\u0026#34;flag.enc\u0026#34;, \u0026#39;rb\u0026#39;).read() seed = 1740845724 def srand(s): global seed seed = s - 1 def rand(): global seed seed = (0x5851F42D4C957F2D * seed + 1) \u0026amp; 0xffffffffffffffff return seed \u0026gt;\u0026gt; 0x21 for t in range(1714521600, 1717200000): srand(t) msg = [] for c in data: rand_num = rand() msg.append(c ^ (rand_num % 0x7f)) msg = bytes(msg) if b\u0026#34;PWNME\u0026#34; in msg: print(msg) Running this will give us the flag: PWNME{4baf3723f62a15f22e86d57130bc40c3}\nC4 License # Using the license of \u0026lsquo;Noa\u0026rsquo; and the provided binary, develop a keygen to create a valid license for the 100 requested users.\nAuthor : Fayred\nFlag format: PWNME{.........................}\nConnect : nc --ssl [Host] 443\nWe are given two files: A binary executable and a sample license for a user named Noa.\nRunning the binary will show us a form. Typing in an invalid license, we\u0026rsquo;ll get Invalid license key. If we use the sample license, we\u0026rsquo;ll get Congratulation, your license key is valid !\nThere are a lot of functions, so it might be a good idea to look for the string Invalid license key in the file.\nTo find a string in IDA, we can use Ctrl+F for IDA 9.0, or Alt+T for older versions. We can see that it\u0026rsquo;s used in the function C4License::on_checkKey_clicked. This function will base64 decrypt our license and get user and serial from the decrypted JSON string. These will be passed to the checker function, which checks the values as follows:\nFirst, it uses the crc32 checksum of user (which is a1) to set the seed through srand. Then, it generates two random numbers to make the key v26, which is used as the key for RC4 decryption: v3 = *((unsigned int *)a1 + 2); v4 = *a1; v27 = __readfsqword(0x28u); v5 = crc32(0LL, v4, v3); srand(v5); v6 = rand(); *(_DWORD *)v26 = _byteswap_ulong(rand() % 0xFFFF * (v6 % 0xFFFF)); RC4::RC4((RC4 *)v25, v26); After that, it will hex decode the serial (a2) and RC4 decrypt it using the key above. The result will be stored in v22 RC4::RC4((RC4 *)v25, v26); QByteArray::fromHex((QByteArray *)\u0026amp;v24, a2); RC4::decrypt(\u0026amp;v22, v25, \u0026amp;v24); Finally, it will compare the SHA1 checksum of v22 and compare it with b039d6daea04c40874f80459bff40142bd25b995. The hash is not crackable, but through debugging using the sample license, we see that v22 is PwNmE_c4_message!137.\nFrom this, we can write a script that takes 100 username from the server and generate the licenses:\nShow solve script\rfrom base64 import b64encode, b64decode from Crypto.Cipher import ARC4 from ctypes import CDLL from zlib import crc32 from pwn import * import time libc = CDLL(\u0026#34;libc.so.6\u0026#34;) def gen_license(username): username = username.encode() seed = crc32(username) print(hex(seed)) libc.srand(seed) n1 = libc.rand() n2 = libc.rand() n = (n1 % 0xffff) * (n2 % 0xffff) print(hex(n)) rc4_key = bytes.fromhex(hex(n).replace(\u0026#34;0x\u0026#34;, \u0026#39;\u0026#39;).zfill(8)) print(\u0026#34;key:\u0026#34; , rc4_key.hex()) rc4 = ARC4.new(rc4_key) enc = rc4.encrypt(b\u0026#34;PwNmE_c4_message!137\u0026#34;) password = enc.hex() license = f\u0026#39;{{\u0026#34;user\u0026#34;:\u0026#34;{username.decode()}\u0026#34;,\u0026#34;serial\u0026#34;:\u0026#34;{password}\u0026#34;}}\u0026#39; print(license) return b64encode(license.encode()).decode() # print(gen_license(\u0026#34;Noa\u0026#34;).decode()) p = remote(\u0026#34;c4license-90c9d36428b43675.deploy.phreaks.fr\u0026#34;, 443, ssl=True) # context.log_level = \u0026#39;debug\u0026#39; for i in range(100): msg = p.recvuntil(b\u0026#34;user :\u0026#34;).decode() print(msg) username = msg.split(\u0026#34;Your license for \u0026#34;)[1].split(\u0026#34; user\u0026#34;)[0].strip() print(username) license = gen_license(username) p.sendline(license.encode()) time.sleep(0.5) p.interactive() Mimirev # A new and obscure programming language, MimiLang, has surfaced. It runs on a peculiar interpreter, but something about it feelsâ€¦ off. Dive into its inner workings and figure out what\u0026rsquo;s really going on. Maybe you\u0026rsquo;ll uncover something unexpected.\nAuthor : Lxt3h\nFlag format: PWNME{.........................}\nWe are given a binary executable which runs the code in a .mimi file. Let\u0026rsquo;s look in IDA!\nIt seems like it\u0026rsquo;s a Golang binary. When analysing a non-stripped Golang or Rust file, the first thing that I do is looking for interesting function names:\nWell look at that, there is a github_com_Lexterl33t_mimicompiler_vm_decryptFlag function. And it\u0026rsquo;s used by github_com_Lexterl33t_mimicompiler_vm__ptr_VM_VerifyProof.\nAnalysing the function, we see that the function does the following:\nIt pops two values x and y from the stack and checks some constraints: x + y == 314159 (x * x + y * y * y - x * y) % 1048573 == 273262 If x and y satisfy the constraints, they will be formatted as %d:%d. Then the function takes the SHA256 sum of this to decrypt the flag using github_com_Lexterl33t_mimicompiler_vm_decryptFlag: v30 = runtime_convT64(x, v24, v25, 1, 1, v26, v27, v28, v29, v69); *(_QWORD *)\u0026amp;v93 = \u0026#34;\\b\u0026#34;; *((_QWORD *)\u0026amp;v93 + 1) = v30; v36 = runtime_convT64(y, v24, v31, 1, 1, v32, v33, v34, v35, v70); *(_QWORD *)\u0026amp;v94 = \u0026#34;\\b\u0026#34;; *((_QWORD *)\u0026amp;v94 + 1) = v36; v41 = fmt_Sprintf((unsigned int)\u0026#34;%d:%d\u0026#34;, 5, (unsigned int)\u0026amp;v93, 2, 2, v37, v38, v39, v40, v71, v76, v79, v84); v46 = runtime_stringtoslicebyte((unsigned int)\u0026amp;v87, v41, 5, 2, 2, v42, v43, v44, v45, v72, v77, v80); crypto_sha256_Sum256(v46, v41, v47, 2, 2, v48, v49, v50, v51, v73, v81, v85); v86[0] = v74; v86[1] = v82; v52 = a1[8]; v56 = github_com_Lexterl33t_mimicompiler_vm_decryptFlag( (__int64)a1[7], (signed __int64)v52, (__int64)a1[9], (__int64)v86, 16LL, 32, v53, v54, v55); I will not try to explain github_com_Lexterl33t_mimicompiler_vm_decryptFlag fully, but it seems like the SHA256 checksum is used as the key for AES decryption (the first 16 bytes). So what is being decrypted here?\nWe haven\u0026rsquo;t even looked at the main function yet. In the main function, there is a part where it creates a new VM:\nv170 = github_com_Lexterl33t_mimicompiler_vm_NewVM( v79, (_DWORD)v52, v80, (unsigned int)\u0026#34;mTfYS2+3UoKAO+gueELVdxNc6QDBwKW1t8uN5Dx/HIGvWb7kMtmLoyt6SB0EIw39\u0026#34;, 64, (unsigned int)\u0026#34;11466b4b07a438fdba619b86088353976073d790344cbf4dae99512028808ecf\u0026#34;, 64, v83, v84, v125, v136, v143, v149, v153, v154); Looking at this function, there are some interesting stuffs:\n__int64 __golang github_com_Lexterl33t_mimicompiler_vm_NewVM( __int64 a1, __int64 a2, __int64 a3, __int64 sus_base64, int _64, __int64 sus_hex, __int64 _64__, int a8, int a9) { // variables ... v30 = encoding_base64__ptr_Encoding_DecodeString( qword_5A57B8, sus_base64, _64, sus_base64, _64, sus_hex, _64__, a8, a9); // ... if ( dword_5C5970 ) { result = runtime_gcWriteBarrier4(); v23 = a1; *v27 = a1; v24 = v31; v27[1] = v31; base64_decrypted = v30; v27[2] = v30; sus_hex_ = sus_hex; v27[3] = sus_hex; } else { v23 = a1; v24 = v31; base64_decrypted = v30; sus_hex_ = sus_hex; } *(_QWORD *)(result + 24) = v23; *(_QWORD *)(result + 48) = v24; *(_QWORD *)(result + 64) = sus_base64; *(_QWORD *)(result + 72) = v28; *(_QWORD *)(result + 56) = base64_decrypted; *(_QWORD *)(result + 88) = _64__; *(_QWORD *)(result + 80) = sus_hex_; return result; } We can see that base64 string is decrypted and stored in result[7] (result + 56). Looking back at github_com_Lexterl33t_mimicompiler_vm_decryptFlag, we can see that this is used as the first argument. The hex string isn\u0026rsquo;t used in this function tho, so maybe it\u0026rsquo;s AES ECB.\nWith the informations that we have, let\u0026rsquo;s try to decrypt the flag! First, we need to find x and y. We can write a quick script to brute-force the solution:\nfrom hashlib import sha256 for x in range(314159+1): y = 314159 - x if (x * x + y * y * y - x * y) % 1048573 == 273262: key = f\u0026#34;{x}:{y}\u0026#34; hash = sha256(key.encode()).hexdigest() print(key) 123456:190703 b9b6c6cd17cdb9bc1ff86179883e65116555b6766df2498281cd331366eae5d3\r206712:107447 82bd2f75c8fb42d505bbd5b97b0d110f67f493ff74b16d247abbf34f01276459 We get two keys. Trying each key (the first 16 bytes), we can see that the first one gives the flag:\nSuper secure network # I actually did this challenge with my friends jitensha69 and severus. You can see severus\u0026rsquo;s writeup for this challenge here\nMisc # Decode Runner # Welcome to Decode Runner ! You will receive 100 encoded words. Your goal is to decode them and send back the decoded word. You have 3 seconds to respond to each word. Good luck!\nAuthor : Offpath\nFlag format: PWNME{.........................}\nConnect : nc --ssl [host] 443\nI did this challenge with my friend KangTheConq. There are a lot of ciphers used here (about 10 ciphers). Let\u0026rsquo;s walk through each of them:\nLatin Gibberish Cipher: hint: what is this charabia ???\rcipher: siruosus I asked GPT and it said that charabia is gibberish in French. Googling gibberish cipher returns Latin Gibberish Cipher. It basically reverses the word and add some suffix.\nTo decrypt this, just remove the last two letters and reverse the string:\ndef latin_gibberish(s): data = s[:-2] return data[::-1] Wabun code (Japanese Morse): hint: It looks like Morse code, but ...\rcipher: f .- g At first, it seems like this is just Morse code. But when submitting the decoded word, the server saids wrong answer.\nSo what kind of Morse code is this? Turns out, there is another Morse code type named Wabun code. It encode Japanese words using Morse code. I wrote a dirty script to decrypt this (This might not always return the correct result, but it works lol):\nShow script\rdef wabi_sabi(ciphertext): qod6 = { # Row 1 \u0026#34;A\u0026#34;: \u0026#34;--.--\u0026#34;, \u0026#34;I\u0026#34;: \u0026#34;.-\u0026#34;, \u0026#34;U\u0026#34;: \u0026#34;..-\u0026#34;, \u0026#34;E\u0026#34;: \u0026#34;-.---\u0026#34;, \u0026#34;O\u0026#34;: \u0026#34;.-...\u0026#34;, \u0026#34;N\u0026#34;: \u0026#34;.-.-.\u0026#34;, # Row 2 \u0026#34;KA\u0026#34;: \u0026#34;.-..\u0026#34;, \u0026#34;KI\u0026#34;: \u0026#34;-.-..\u0026#34;, \u0026#34;KU\u0026#34;: \u0026#34;...-\u0026#34;, \u0026#34;KE\u0026#34;: \u0026#34;-.--\u0026#34;, \u0026#34;KO\u0026#34;: \u0026#34;----\u0026#34;, # Row 3 \u0026#34;SA\u0026#34;: \u0026#34;-.-.-\u0026#34;, \u0026#34;SHI\u0026#34;: \u0026#34;--.-.\u0026#34;, \u0026#34;SU\u0026#34;: \u0026#34;---.-\u0026#34;, \u0026#34;SE\u0026#34;: \u0026#34;.---.\u0026#34;, \u0026#34;SO\u0026#34;: \u0026#34;---.\u0026#34;, # # Row 4 # \u0026#34;ZA\u0026#34;: \u0026#34;-.-.\u0026#34;, # \u0026#34;ZI\u0026#34;: \u0026#34;-.--\u0026#34;, # \u0026#34;ZU\u0026#34;: \u0026#34;..--\u0026#34;, # \u0026#34;ZE\u0026#34;: \u0026#34;.--.\u0026#34;, # \u0026#34;ZO\u0026#34;: \u0026#34;---.\u0026#34;, # Row 5 \u0026#34;TA\u0026#34;: \u0026#34;-.\u0026#34;, \u0026#34;CHI\u0026#34;: \u0026#34;..-.\u0026#34;, \u0026#34;TSU\u0026#34;: \u0026#34;.--.\u0026#34;, \u0026#34;TE\u0026#34;: \u0026#34;.-.--\u0026#34;, \u0026#34;TO\u0026#34;: \u0026#34;..-..\u0026#34;, # # Row 6 # \u0026#34;DA\u0026#34;: \u0026#34;-.\u0026#34;, # \u0026#34;DI\u0026#34;: \u0026#34;----\u0026#34;, # \u0026#34;DU\u0026#34;: \u0026#34;--.-\u0026#34;, # \u0026#34;DE\u0026#34;: \u0026#34;-..-\u0026#34;, # \u0026#34;DO\u0026#34;: \u0026#34;--..\u0026#34;, # Row 7 \u0026#34;NA\u0026#34;: \u0026#34;.-.\u0026#34;, \u0026#34;NI\u0026#34;: \u0026#34;-.-.\u0026#34;, \u0026#34;NU\u0026#34;: \u0026#34;....\u0026#34;, \u0026#34;NE\u0026#34;: \u0026#34;--.-\u0026#34;, \u0026#34;NO\u0026#34;: \u0026#34;..--\u0026#34;, # Row 8 \u0026#34;HA\u0026#34;: \u0026#34;-...\u0026#34;, \u0026#34;HI\u0026#34;: \u0026#34;--..-\u0026#34;, \u0026#34;FU\u0026#34;: \u0026#34;--..\u0026#34;, \u0026#34;HE\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;HO\u0026#34;: \u0026#34;-..\u0026#34;, # # Row 9 # \u0026#34;BA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;BI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;BU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;BE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;BO\u0026#34;: \u0026#34;.--..\u0026#34;, # # Row 10 # \u0026#34;PA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;PI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;PU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;PE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;PO\u0026#34;: \u0026#34;.--..\u0026#34;, # Row 11 \u0026#34;MA\u0026#34;: \u0026#34;-..-\u0026#34;, \u0026#34;MI\u0026#34;: \u0026#34;..-.-\u0026#34;, \u0026#34;MU\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;ME\u0026#34;: \u0026#34;-...-\u0026#34;, \u0026#34;MO\u0026#34;: \u0026#34;-..-.\u0026#34;, # Row 12 \u0026#34;YA\u0026#34;: \u0026#34;.--\u0026#34;, \u0026#34;YU\u0026#34;: \u0026#34;-..--\u0026#34;, \u0026#34;YO\u0026#34;: \u0026#34;--\u0026#34;, \u0026#34;RA\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;RI\u0026#34;: \u0026#34;--.\u0026#34;, \u0026#34;RU\u0026#34;: \u0026#34;-.--.\u0026#34;, \u0026#34;RE\u0026#34;: \u0026#34;---\u0026#34;, \u0026#34;RO\u0026#34;: \u0026#34;.-.-\u0026#34;, \u0026#34;WA\u0026#34;: \u0026#34;-.-\u0026#34;, \u0026#34;WI\u0026#34;: \u0026#34;.-..-\u0026#34;, \u0026#34;WE\u0026#34;: \u0026#34;.--..\u0026#34;, \u0026#34;WO\u0026#34;: \u0026#34;.---\u0026#34;, } DICT = {} for key, value in qod6.items(): DICT[value] = key ciphertext = ciphertext.split() ans = \u0026#39;\u0026#39; for word in ciphertext: if \u0026#39;.\u0026#39; in word or \u0026#39;-\u0026#39; in word: ans += DICT[word] else: ans += word return ans.lower() First Letter: cipher: India Golf Uniform Alfa November Oscar Delta Oscar November There isn\u0026rsquo;t a hint for this one. We can solve this by taking the first letter of each word to form a new word:\ndef first_letter(s): s = s.split() s = [i[0] for i in s] s = \u0026#34;\u0026#34;.join(s) return s.lower() Chord cipher: hint: Hendrix would have had it...\rcipher: x24442 x02220 xx0232 320003 022100 xx0232 A quick Google shows that Jimi Hendrix is an American guitarist and songwriter. Moreover, the cipher looks like guitar chord, so this might be Chord cipher:\ndef chord_cipher(ciphertext): ciphertext = ciphertext.split() dict = {\u0026#34;x02220\u0026#34;: \u0026#39;a\u0026#39;, \u0026#34;224442\u0026#34;:\u0026#39;b\u0026#39;, \u0026#39;032010\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;xx0232\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;022100\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;133211\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;320003\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;x24442\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;x32010\u0026#39;:\u0026#39;c\u0026#39;} ans = \u0026#39;\u0026#39; for i in ciphertext: ans += dict.get(i, \u0026#39;?\u0026#39;) return ans Baudot Code hint: He can\u0026#39;t imagine finding himself in CTF 150 years later...\rcipher: 01111 11000 00011 10010 00011 This looks like Morse code, but each \u0026ldquo;word\u0026rdquo; is only 5-digit long. A quick ChatGPT gives Baudot Code:\nbaudot_table = {\r\u0026#34;00000\u0026#34;: \u0026#34;null\u0026#34;, \u0026#34;00100\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;10111\u0026#34;: \u0026#34;Q\u0026#34;, \u0026#34;10011\u0026#34;: \u0026#34;W\u0026#34;,\r\u0026#34;00001\u0026#34;: \u0026#34;E\u0026#34;, \u0026#34;01010\u0026#34;: \u0026#34;R\u0026#34;, \u0026#34;10000\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;10101\u0026#34;: \u0026#34;Y\u0026#34;,\r\u0026#34;00111\u0026#34;: \u0026#34;U\u0026#34;, \u0026#34;00110\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;11000\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;10110\u0026#34;: \u0026#34;P\u0026#34;,\r\u0026#34;00011\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;00101\u0026#34;: \u0026#34;S\u0026#34;, \u0026#34;01001\u0026#34;: \u0026#34;D\u0026#34;, \u0026#34;01101\u0026#34;: \u0026#34;F\u0026#34;,\r\u0026#34;11010\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;10100\u0026#34;: \u0026#34;H\u0026#34;, \u0026#34;01011\u0026#34;: \u0026#34;J\u0026#34;, \u0026#34;01111\u0026#34;: \u0026#34;K\u0026#34;,\r\u0026#34;10010\u0026#34;: \u0026#34;L\u0026#34;, \u0026#34;10001\u0026#34;: \u0026#34;Z\u0026#34;, \u0026#34;11101\u0026#34;: \u0026#34;X\u0026#34;, \u0026#34;01110\u0026#34;: \u0026#34;C\u0026#34;,\r\u0026#34;11110\u0026#34;: \u0026#34;V\u0026#34;, \u0026#34;11001\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;01100\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;11100\u0026#34;: \u0026#34;M\u0026#34;,\r\u0026#34;01000\u0026#34;: \u0026#34;CR\u0026#34;, \u0026#34;00010\u0026#34;: \u0026#34;LF\u0026#34;, \u0026#34;11011\u0026#34;: \u0026#34;Switch to Digits\u0026#34;\r}\rdef baudot_decode(ciphertext):\rbits = ciphertext.split()\rdecoded_text = \u0026#34;\u0026#34;.join(baudot_table.get(bit, \u0026#34;?\u0026#34;) for bit in bits)\rreturn decoded_text.lower() Trimethius Cipher: hint: Born in 1462 in Germany...\rcipher: rmxksmc Googling the hint gives Johannes Trithemius. Googling the cipher gives Trimethius Cipher.\nWe can use Try all shifts (bruteforce) on dcode and we\u0026rsquo;ll see that offset +3 gives meaningful words. I wrote a script for this:\ndef trimethius_decode(ciphertext): ALPHABET = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.lower() offset = 3 ans = \u0026#34;\u0026#34; for i in range(len(ciphertext)): idx = ALPHABET.index(ciphertext[i]) ans += ALPHABET[(idx - offset + len(ALPHABET)) % len(ALPHABET)] offset += 1 return ans Chuck Norris Unary Code hint: He can snap his toes, and has already counted to infinity twice ...\rcipher: 0 0000 00 000 0 0000 00 00 0 000 00 0 0 00 00 00 0 00 00 0 0 000000 00 000 0 0000 00 0 0 0000000 00 0000 0 00 00 00 0 0 00 0 0 0 My friend KangTheConq found out that this is Chuck Norris Unary Code, and he writes the decoding script too:\ndef decode_chuck_norris(unary_code): parts = unary_code.split() binary_string = \u0026#34;\u0026#34; for i in range(0, len(parts), 2): bit = \u0026#39;1\u0026#39; if parts[i] == \u0026#39;0\u0026#39; else \u0026#39;0\u0026#39; binary_string += bit * len(parts[i + 1]) decoded_text = \u0026#34;\u0026#34; for i in range(0, len(binary_string), 7): decoded_text += chr(int(binary_string[i:i+7], 2)) return decoded_text Shankar Speech Defect hint: Did you realy see slumdog millionaire ?\rcipher: PJWX Googling slumdog millionaire cipher gives Shankar Speech Defect. It\u0026rsquo;s just another substitution cipher:\ndef slumdog(ciphertext): cipheralphabet = \u0026#39;XWYAZBCDQEFGHIKLMNOPJRSTUV\u0026#39; plainalphabet = string.ascii_uppercase plaintext = \u0026#39;\u0026#39; for c in ciphertext: if c == \u0026#39; \u0026#39;: p = \u0026#39; \u0026#39; else: p = plainalphabet[cipheralphabet.index(c)] plaintext += p return plaintext.lower() Morbit Cipher: hint: A code based on pairs of dots and dashes. Think of a mix of Morse code and numbers... (AZERTYUIO)\rcipher: 2557122917522 KangTheConq clutched again and found out that this is Morbit Cipher:\nMORSE_CODE_DICT = {\u0026#39;..-\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;--..--\u0026#39;: \u0026#39;, \u0026#39;, \u0026#39;....-\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;.....\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;-...\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;-..-\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;.-.\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;--.-\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;--..\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;.--\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;-..-.\u0026#39;: \u0026#39;/\u0026#39;, \u0026#39;..---\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;.-\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;..\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;-.-.\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;..-.\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;---\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;-.--\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;-\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;.\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;.-..\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;...\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;-.--.-\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;..--..\u0026#39;: \u0026#39;?\u0026#39;, \u0026#39;.----\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;-----\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;-.-\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;-..\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;----.\u0026#39;: \u0026#39;9\u0026#39;, \u0026#39;-....\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;.---\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;.--.\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;.-.-.-\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;-.--.\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;--\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;-.\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;....\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;---..\u0026#39;: \u0026#39;8\u0026#39;, \u0026#39;...-\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;--...\u0026#39;: \u0026#39;7\u0026#39;, \u0026#39;--.\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;...--\u0026#39;: \u0026#39;3\u0026#39;, \u0026#39;-....-\u0026#39;: \u0026#39;-\u0026#39;} MORBIT = [\u0026#39;..\u0026#39;, \u0026#39;. \u0026#39;, \u0026#39; -\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;-.\u0026#39;, \u0026#39;--\u0026#39;, \u0026#39; .\u0026#39;, \u0026#39;- \u0026#39;, \u0026#39;.-\u0026#39;] KEY = \u0026#34;AZERTYUIO\u0026#34; # Given key # Map digits to Morbit symbols using the key MORBIT_CODE_DICT = dict(zip(\u0026#34;123456789\u0026#34;, MORBIT)) def morse(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morse code string to plaintext. \u0026#34;\u0026#34;\u0026#34; plaintxt = \u0026#39;\u0026#39; for word in ciphertxt.strip().split(\u0026#34; \u0026#34;): for c in word.strip().split(\u0026#34; \u0026#34;): if c in MORSE_CODE_DICT: plaintxt += MORSE_CODE_DICT[c] plaintxt += \u0026#39; \u0026#39; return plaintxt.strip() def morbit(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morbit cipher text into Morse code, then to plaintext. \u0026#34;\u0026#34;\u0026#34; morsetxt = \u0026#34;\u0026#34;.join(MORBIT_CODE_DICT[c] for c in ciphertxt if c in MORBIT_CODE_DICT) return morse(morsetxt).lower() Combining all of this, we get this final script:\nShow script\rfrom pwn import * import string HOST = \u0026#39;decoderunner-6bf56818dcc9ea04.deploy.phreaks.fr\u0026#39; PORT = 443 p = remote(HOST, PORT, ssl=True) # p = remote(HOST, PORT) def latin_gibberish(s): data = s[:-2] return data[::-1] def decode_1337(s): leet_dict = { \u0026#39;4\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;/\\\\\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;@\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;/-\\\\\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;|3\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;13\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;(\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;\u0026lt;\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;Â©\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;[)\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;|\u0026gt;\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;|)\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;â‚¬\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;[-\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;|=\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;/=\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;6\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;(_+\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;#\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;/-/\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;[-]\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;]-[\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;)-(\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;(-)\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;|-|\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;I\u0026#39;, \u0026#34;1\u0026#39;\u0026#34;: \u0026#39;I\u0026#39;, \u0026#39;!\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;|\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;_|\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;_/\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;|\u0026lt;\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;|{\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;|_\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;Â£\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;1_\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;|V|\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;|\\/|\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;/\\/\\\\\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;/V\\\\\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;|\\|\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;/\\/\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;[\\]\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;/V\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;[]\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;()\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;\u0026lt;\u0026gt;\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;|*\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;|o\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;|Â°\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;/*\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;()_\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;0_\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;Â°|\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;(_,)\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;|?\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;Â®\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;|2\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;5\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;$\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;Â§\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;â€ \u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;Â¯|Â¯\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;(_)\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;|_|\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;Âµ\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;\\/\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;|/\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;\\/\\/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;vv\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\\^/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\\|/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\\_|_/\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;\u0026gt;\u0026lt;\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;)(\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;`/\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;Â¥\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;\\/\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#34;7_\u0026#39;\u0026#34;: \u0026#39;Z\u0026#39;, \u0026#39;\u0026gt;_\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;â‰¥\u0026#39;: \u0026#39;Z\u0026#39; } result = s for leet, char in sorted(leet_dict.items(), key=lambda x: -len(x[0])): result = result.replace(leet, char) return result.lower() def slumdog(ciphertext): cipheralphabet = \u0026#39;XWYAZBCDQEFGHIKLMNOPJRSTUV\u0026#39; plainalphabet = string.ascii_uppercase plaintext = \u0026#39;\u0026#39; for c in ciphertext: if c == \u0026#39; \u0026#39;: p = \u0026#39; \u0026#39; else: p = plainalphabet[cipheralphabet.index(c)] plaintext += p return plaintext.lower() def weird_morse(s): MORSE_CODE_DICT = { \u0026#39;A\u0026#39;:\u0026#39;.-\u0026#39;, \u0026#39;B\u0026#39;:\u0026#39;-...\u0026#39;, \u0026#39;C\u0026#39;:\u0026#39;-.-.\u0026#39;, \u0026#39;D\u0026#39;:\u0026#39;-..\u0026#39;, \u0026#39;E\u0026#39;:\u0026#39;.\u0026#39;, \u0026#39;F\u0026#39;:\u0026#39;..-.\u0026#39;, \u0026#39;G\u0026#39;:\u0026#39;--.\u0026#39;, \u0026#39;H\u0026#39;:\u0026#39;....\u0026#39;, \u0026#39;I\u0026#39;:\u0026#39;..\u0026#39;, \u0026#39;J\u0026#39;:\u0026#39;.---\u0026#39;, \u0026#39;K\u0026#39;:\u0026#39;-.-\u0026#39;, \u0026#39;L\u0026#39;:\u0026#39;.-..\u0026#39;, \u0026#39;M\u0026#39;:\u0026#39;--\u0026#39;, \u0026#39;N\u0026#39;:\u0026#39;-.\u0026#39;, \u0026#39;O\u0026#39;:\u0026#39;---\u0026#39;, \u0026#39;P\u0026#39;:\u0026#39;.--.\u0026#39;, \u0026#39;Q\u0026#39;:\u0026#39;--.-\u0026#39;, \u0026#39;R\u0026#39;:\u0026#39;.-.\u0026#39;, \u0026#39;S\u0026#39;:\u0026#39;...\u0026#39;, \u0026#39;T\u0026#39;:\u0026#39;-\u0026#39;, \u0026#39;U\u0026#39;:\u0026#39;..-\u0026#39;, \u0026#39;V\u0026#39;:\u0026#39;...-\u0026#39;, \u0026#39;W\u0026#39;:\u0026#39;.--\u0026#39;, \u0026#39;X\u0026#39;:\u0026#39;-..-\u0026#39;, \u0026#39;Y\u0026#39;:\u0026#39;-.--\u0026#39;, \u0026#39;Z\u0026#39;:\u0026#39;--..\u0026#39;, \u0026#39;1\u0026#39;:\u0026#39;.----\u0026#39;, \u0026#39;2\u0026#39;:\u0026#39;..---\u0026#39;, \u0026#39;3\u0026#39;:\u0026#39;...--\u0026#39;, \u0026#39;4\u0026#39;:\u0026#39;....-\u0026#39;, \u0026#39;5\u0026#39;:\u0026#39;.....\u0026#39;, \u0026#39;6\u0026#39;:\u0026#39;-....\u0026#39;, \u0026#39;7\u0026#39;:\u0026#39;--...\u0026#39;, \u0026#39;8\u0026#39;:\u0026#39;---..\u0026#39;, \u0026#39;9\u0026#39;:\u0026#39;----.\u0026#39;, \u0026#39;0\u0026#39;:\u0026#39;-----\u0026#39;, \u0026#39;, \u0026#39;:\u0026#39;--..--\u0026#39;, \u0026#39;.\u0026#39;:\u0026#39;.-.-.-\u0026#39;, \u0026#39;?\u0026#39;:\u0026#39;..--..\u0026#39;, \u0026#39;/\u0026#39;:\u0026#39;-..-.\u0026#39;, \u0026#39;-\u0026#39;:\u0026#39;-....-\u0026#39;, \u0026#39;(\u0026#39;:\u0026#39;-.--.\u0026#39;, \u0026#39;)\u0026#39;:\u0026#39;-.--.-\u0026#39;} MORSE_CODE_DICT_DECODE = {} for key, value in MORSE_CODE_DICT.items(): MORSE_CODE_DICT_DECODE[value] = key ans = \u0026#34;\u0026#34; s = s.split() for c in s: if \u0026#34;-\u0026#34; in c or \u0026#34;.\u0026#34; in c: c = c.replace(\u0026#34;-\u0026#34;, \u0026#39;#\u0026#39;).replace(\u0026#34;.\u0026#34;, \u0026#39;-\u0026#39;).replace(\u0026#34;#\u0026#34;, \u0026#39;.\u0026#39;) ans += MORSE_CODE_DICT_DECODE[c] else: ans += c return ans def first_letter(s): s = s.split() s = [i[0] for i in s] s = \u0026#34;\u0026#34;.join(s) return s.lower() def decode_chuck_norris(unary_code): parts = unary_code.split() binary_string = \u0026#34;\u0026#34; for i in range(0, len(parts), 2): bit = \u0026#39;1\u0026#39; if parts[i] == \u0026#39;0\u0026#39; else \u0026#39;0\u0026#39; binary_string += bit * len(parts[i + 1]) decoded_text = \u0026#34;\u0026#34; for i in range(0, len(binary_string), 7): decoded_text += chr(int(binary_string[i:i+7], 2)) return decoded_text MORSE_CODE_DICT = {\u0026#39;..-\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;--..--\u0026#39;: \u0026#39;, \u0026#39;, \u0026#39;....-\u0026#39;: \u0026#39;4\u0026#39;, \u0026#39;.....\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;-...\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;-..-\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;.-.\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;--.-\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;--..\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;.--\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;-..-.\u0026#39;: \u0026#39;/\u0026#39;, \u0026#39;..---\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;.-\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;..\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;-.-.\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;..-.\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;---\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;-.--\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;-\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;.\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;.-..\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;...\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;-.--.-\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;..--..\u0026#39;: \u0026#39;?\u0026#39;, \u0026#39;.----\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;-----\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;-.-\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;-..\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;----.\u0026#39;: \u0026#39;9\u0026#39;, \u0026#39;-....\u0026#39;: \u0026#39;6\u0026#39;, \u0026#39;.---\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;.--.\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;.-.-.-\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;-.--.\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;--\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;-.\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;....\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;---..\u0026#39;: \u0026#39;8\u0026#39;, \u0026#39;...-\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;--...\u0026#39;: \u0026#39;7\u0026#39;, \u0026#39;--.\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;...--\u0026#39;: \u0026#39;3\u0026#39;, \u0026#39;-....-\u0026#39;: \u0026#39;-\u0026#39;} MORBIT = [\u0026#39;..\u0026#39;, \u0026#39;. \u0026#39;, \u0026#39; -\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;-.\u0026#39;, \u0026#39;--\u0026#39;, \u0026#39; .\u0026#39;, \u0026#39;- \u0026#39;, \u0026#39;.-\u0026#39;] KEY = \u0026#34;AZERTYUIO\u0026#34; # Given key # Map digits to Morbit symbols using the key MORBIT_CODE_DICT = dict(zip(\u0026#34;123456789\u0026#34;, MORBIT)) def morse(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morse code string to plaintext. \u0026#34;\u0026#34;\u0026#34; plaintxt = \u0026#39;\u0026#39; for word in ciphertxt.strip().split(\u0026#34; \u0026#34;): for c in word.strip().split(\u0026#34; \u0026#34;): if c in MORSE_CODE_DICT: plaintxt += MORSE_CODE_DICT[c] plaintxt += \u0026#39; \u0026#39; return plaintxt.strip() def morbit(ciphertxt): \u0026#34;\u0026#34;\u0026#34; Decodes a Morbit cipher text into Morse code, then to plaintext. \u0026#34;\u0026#34;\u0026#34; morsetxt = \u0026#34;\u0026#34;.join(MORBIT_CODE_DICT[c] for c in ciphertxt if c in MORBIT_CODE_DICT) return morse(morsetxt).lower() baudot_table = { \u0026#34;00000\u0026#34;: \u0026#34;null\u0026#34;, \u0026#34;00100\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;10111\u0026#34;: \u0026#34;Q\u0026#34;, \u0026#34;10011\u0026#34;: \u0026#34;W\u0026#34;, \u0026#34;00001\u0026#34;: \u0026#34;E\u0026#34;, \u0026#34;01010\u0026#34;: \u0026#34;R\u0026#34;, \u0026#34;10000\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;10101\u0026#34;: \u0026#34;Y\u0026#34;, \u0026#34;00111\u0026#34;: \u0026#34;U\u0026#34;, \u0026#34;00110\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;11000\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;10110\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;00011\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;00101\u0026#34;: \u0026#34;S\u0026#34;, \u0026#34;01001\u0026#34;: \u0026#34;D\u0026#34;, \u0026#34;01101\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;11010\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;10100\u0026#34;: \u0026#34;H\u0026#34;, \u0026#34;01011\u0026#34;: \u0026#34;J\u0026#34;, \u0026#34;01111\u0026#34;: \u0026#34;K\u0026#34;, \u0026#34;10010\u0026#34;: \u0026#34;L\u0026#34;, \u0026#34;10001\u0026#34;: \u0026#34;Z\u0026#34;, \u0026#34;11101\u0026#34;: \u0026#34;X\u0026#34;, \u0026#34;01110\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;11110\u0026#34;: \u0026#34;V\u0026#34;, \u0026#34;11001\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;01100\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;11100\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;01000\u0026#34;: \u0026#34;CR\u0026#34;, \u0026#34;00010\u0026#34;: \u0026#34;LF\u0026#34;, \u0026#34;11011\u0026#34;: \u0026#34;Switch to Digits\u0026#34; } def baudot_decode(ciphertext): bits = ciphertext.split() decoded_text = \u0026#34;\u0026#34;.join(baudot_table.get(bit, \u0026#34;?\u0026#34;) for bit in bits) return decoded_text.lower() def trimethius_decode(ciphertext): ALPHABET = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.lower() offset = 3 ans = \u0026#34;\u0026#34; for i in range(len(ciphertext)): idx = ALPHABET.index(ciphertext[i]) ans += ALPHABET[(idx - offset + len(ALPHABET)) % len(ALPHABET)] offset += 1 return ans def wabi_sabi(ciphertext): qod6 = { # Row 1 \u0026#34;A\u0026#34;: \u0026#34;--.--\u0026#34;, \u0026#34;I\u0026#34;: \u0026#34;.-\u0026#34;, \u0026#34;U\u0026#34;: \u0026#34;..-\u0026#34;, \u0026#34;E\u0026#34;: \u0026#34;-.---\u0026#34;, \u0026#34;O\u0026#34;: \u0026#34;.-...\u0026#34;, \u0026#34;N\u0026#34;: \u0026#34;.-.-.\u0026#34;, # Row 2 \u0026#34;KA\u0026#34;: \u0026#34;.-..\u0026#34;, \u0026#34;KI\u0026#34;: \u0026#34;-.-..\u0026#34;, \u0026#34;KU\u0026#34;: \u0026#34;...-\u0026#34;, \u0026#34;KE\u0026#34;: \u0026#34;-.--\u0026#34;, \u0026#34;KO\u0026#34;: \u0026#34;----\u0026#34;, # Row 3 \u0026#34;SA\u0026#34;: \u0026#34;-.-.-\u0026#34;, \u0026#34;SHI\u0026#34;: \u0026#34;--.-.\u0026#34;, \u0026#34;SU\u0026#34;: \u0026#34;---.-\u0026#34;, \u0026#34;SE\u0026#34;: \u0026#34;.---.\u0026#34;, \u0026#34;SO\u0026#34;: \u0026#34;---.\u0026#34;, # # Row 4 # \u0026#34;ZA\u0026#34;: \u0026#34;-.-.\u0026#34;, # \u0026#34;ZI\u0026#34;: \u0026#34;-.--\u0026#34;, # \u0026#34;ZU\u0026#34;: \u0026#34;..--\u0026#34;, # \u0026#34;ZE\u0026#34;: \u0026#34;.--.\u0026#34;, # \u0026#34;ZO\u0026#34;: \u0026#34;---.\u0026#34;, # Row 5 \u0026#34;TA\u0026#34;: \u0026#34;-.\u0026#34;, \u0026#34;CHI\u0026#34;: \u0026#34;..-.\u0026#34;, \u0026#34;TSU\u0026#34;: \u0026#34;.--.\u0026#34;, \u0026#34;TE\u0026#34;: \u0026#34;.-.--\u0026#34;, \u0026#34;TO\u0026#34;: \u0026#34;..-..\u0026#34;, # # Row 6 # \u0026#34;DA\u0026#34;: \u0026#34;-.\u0026#34;, # \u0026#34;DI\u0026#34;: \u0026#34;----\u0026#34;, # \u0026#34;DU\u0026#34;: \u0026#34;--.-\u0026#34;, # \u0026#34;DE\u0026#34;: \u0026#34;-..-\u0026#34;, # \u0026#34;DO\u0026#34;: \u0026#34;--..\u0026#34;, # Row 7 \u0026#34;NA\u0026#34;: \u0026#34;.-.\u0026#34;, \u0026#34;NI\u0026#34;: \u0026#34;-.-.\u0026#34;, \u0026#34;NU\u0026#34;: \u0026#34;....\u0026#34;, \u0026#34;NE\u0026#34;: \u0026#34;--.-\u0026#34;, \u0026#34;NO\u0026#34;: \u0026#34;..--\u0026#34;, # Row 8 \u0026#34;HA\u0026#34;: \u0026#34;-...\u0026#34;, \u0026#34;HI\u0026#34;: \u0026#34;--..-\u0026#34;, \u0026#34;FU\u0026#34;: \u0026#34;--..\u0026#34;, \u0026#34;HE\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;HO\u0026#34;: \u0026#34;-..\u0026#34;, # # Row 9 # \u0026#34;BA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;BI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;BU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;BE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;BO\u0026#34;: \u0026#34;.--..\u0026#34;, # # Row 10 # \u0026#34;PA\u0026#34;: \u0026#34;.-..-\u0026#34;, # \u0026#34;PI\u0026#34;: \u0026#34;.-...\u0026#34;, # \u0026#34;PU\u0026#34;: \u0026#34;..-..\u0026#34;, # \u0026#34;PE\u0026#34;: \u0026#34;....\u0026#34;, # \u0026#34;PO\u0026#34;: \u0026#34;.--..\u0026#34;, # Row 11 \u0026#34;MA\u0026#34;: \u0026#34;-..-\u0026#34;, \u0026#34;MI\u0026#34;: \u0026#34;..-.-\u0026#34;, \u0026#34;MU\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;ME\u0026#34;: \u0026#34;-...-\u0026#34;, \u0026#34;MO\u0026#34;: \u0026#34;-..-.\u0026#34;, # Row 12 \u0026#34;YA\u0026#34;: \u0026#34;.--\u0026#34;, \u0026#34;YU\u0026#34;: \u0026#34;-..--\u0026#34;, \u0026#34;YO\u0026#34;: \u0026#34;--\u0026#34;, \u0026#34;RA\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;RI\u0026#34;: \u0026#34;--.\u0026#34;, \u0026#34;RU\u0026#34;: \u0026#34;-.--.\u0026#34;, \u0026#34;RE\u0026#34;: \u0026#34;---\u0026#34;, \u0026#34;RO\u0026#34;: \u0026#34;.-.-\u0026#34;, \u0026#34;WA\u0026#34;: \u0026#34;-.-\u0026#34;, \u0026#34;WI\u0026#34;: \u0026#34;.-..-\u0026#34;, \u0026#34;WE\u0026#34;: \u0026#34;.--..\u0026#34;, \u0026#34;WO\u0026#34;: \u0026#34;.---\u0026#34;, } DICT = {} for key, value in qod6.items(): DICT[value] = key ciphertext = ciphertext.split() ans = \u0026#39;\u0026#39; for word in ciphertext: if \u0026#39;.\u0026#39; in word or \u0026#39;-\u0026#39; in word: ans += DICT[word] else: ans += word return ans.lower() def chord_cipher(ciphertext): ciphertext = ciphertext.split() dict = {\u0026#34;x02220\u0026#34;: \u0026#39;a\u0026#39;, \u0026#34;224442\u0026#34;:\u0026#39;b\u0026#39;, \u0026#39;032010\u0026#39;:\u0026#39;c\u0026#39;, \u0026#39;xx0232\u0026#39;:\u0026#39;d\u0026#39;, \u0026#39;022100\u0026#39;:\u0026#39;e\u0026#39;, \u0026#39;133211\u0026#39;:\u0026#39;f\u0026#39;, \u0026#39;320003\u0026#39;:\u0026#39;g\u0026#39;, \u0026#39;x24442\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;x32010\u0026#39;:\u0026#39;c\u0026#39;} ans = \u0026#39;\u0026#39; for i in ciphertext: ans += dict.get(i, \u0026#39;?\u0026#39;) return ans for i in range(100): hint = p.recvuntil(b\u0026#39;cipher: \u0026#39;).decode() print(hint) cipher = p.recvline().strip().decode() print(cipher) if (\u0026#34;charabia\u0026#34; in hint): msg = latin_gibberish(cipher) print(msg) p.sendline(msg) elif (\u0026#34;1337\u0026#34; in hint): msg = decode_1337(cipher) print(msg) p.sendline(msg) elif (\u0026#34;slumdog\u0026#34; in hint): msg = slumdog(cipher) print(msg) p.sendline(msg) elif (\u0026#34;It looks like Morse code\u0026#34; in hint): msg = wabi_sabi(cipher) print(msg) p.sendline(msg) elif (\u0026#34;hint\u0026#34; not in hint): msg = first_letter(cipher) print(msg) p.sendline(msg) elif (\u0026#34;infinity twice\u0026#34; in hint): msg = decode_chuck_norris(cipher) print(msg) p.sendline(msg) elif (\u0026#34;CTF 150 years\u0026#34; in hint): msg = baudot_decode(cipher) print(msg) p.sendline(msg) elif (\u0026#34;code based on\u0026#34; in hint): msg = morbit(cipher) print(msg) p.sendline(msg) elif (\u0026#34;1462\u0026#34; in hint): msg = trimethius_decode(cipher) print(msg) p.sendline(msg) elif (\u0026#34;Hendrix\u0026#34; in hint): msg = chord_cipher(cipher) print(msg) p.sendline(msg) else: break p.interactive() ","date":"3 March 2025","externalUrl":null,"permalink":"/posts/pwnme-ctf-2025-writeup/","section":"Posts","summary":"Overview # Here are some of the challenges that I solved during PwnMe CTF 2025:","title":"PwnMe CTF 2025 Writeup","type":"posts"},{"content":"","date":"24 February 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]