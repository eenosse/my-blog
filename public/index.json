
[{"content":"","date":"2 March 2025","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"2 March 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"\rprint(\u0026#34;Wasssuuuuuuuupppppppppppppppppp\u0026#34;) ","date":"2 March 2025","externalUrl":null,"permalink":"/","section":"Eenosse's Blog","summary":"\rprint(\u0026#34;Wasssuuuuuuuupppppppppppppppppp\u0026#34;) ","title":"Eenosse's Blog","type":"page"},{"content":"\rOverview #\rHere are some of the challenges that I solved during PwnMe CTF 2025:\nRev #\rBack to the past #\rWe are given a binary executable that encrypts the flag file.\neenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ ./backToThePast Usage: ./backToThePast \u0026lt;filename\u0026gt; eenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ echo 1234 \u0026gt; test eenosse@ITDOLOZI:~/pwnmeCTF_2025/rev_Back_to_the_past$ ./backToThePast test time : 1740925301 Running the binary, we see that it prints out the current timestamp. So it might use the timestamp for encryption. Let\u0026rsquo;s check that in IDA:\nClick to expand\rint __fastcall main(int argc, const char **argv, const char **envp) { char v3; // cl int v5; // edx char v6; // cl int v7; // edx char v8; // cl int v9; // eax char v10; // cl int v11; // [rsp+1Ch] [rbp-124h] unsigned int v12; // [rsp+20h] [rbp-120h] __int64 v13; // [rsp+28h] [rbp-118h] char v14[264]; // [rsp+30h] [rbp-110h] BYREF unsigned __int64 v15; // [rsp+138h] [rbp-8h] v15 = __readfsqword(0x28u); if ( argc \u0026gt; 1 ) { v12 = time(0LL, argv, envp); printf((unsigned int)\u0026#34;time : %ld\\n\u0026#34;, v12, v5, v6); srand(v12); v13 = fopen64(argv[1], \u0026#34;rb+\u0026#34;); if ( v13 ) { while ( 1 ) { v11 = getc(v13); if ( v11 == 0xFFFFFFFF ) { break; } fseek(v13, 0xFFFFFFFFFFFFFFFFLL, 1LL); v9 = rand(); fputc(v11 ^ (unsigned int)(v9 % 0x7F), v13); } fclose(v13); strcpy(v14, argv[1]); strcat(v14, \u0026#34;.enc\u0026#34;); if ( (unsigned int)rename(argv[1], v14) ) { printf( (unsigned int)\u0026#34;Can\u0026#39;t rename %s filename to %s.enc\u0026#34;, (unsigned int)argv[1], (unsigned int)argv[1], v10); return 1; } else { return 0; } } else { printf((unsigned int)\u0026#34;Can\u0026#39;t open file %s\\n\u0026#34;, (unsigned int)argv[1], v7, v8); return 1; } } else { printf((unsigned int)\u0026#34;Usage: %s \u0026lt;filename\u0026gt;\\n\u0026#34;, (unsigned int)*argv, (_DWORD)envp, v3); return 1; } } Indeed, it uses the timestamp to set seed, then XOR our file with random numbers and write it to a .enc file.\nThings should be easy enough. However, when I tried to write a solve script using libc\u0026rsquo;s random, it didn\u0026rsquo;t give the right result. After debugging, I noticed that the random numbers of the program were different from mine. So something has been changed ðŸ¤”.\nIt turns out the srand and rand functions are not the standard libc functions, but rather custom functions:\n__int64 __fastcall srand(int a1) { __int64 result; // rax result = (unsigned int)(a1 - 1); seed = result; return result; } unsigned __int64 rand() { seed = 0x5851F42D4C957F2DLL * seed + 1; return (unsigned __int64)seed \u0026gt;\u0026gt; 0x21; } The srand function actually sets the seed to be equal to a1 - 1. I\u0026rsquo;m not sure if rand is different from the standard one, but we\u0026rsquo;ll not care about that.\nFrom this, I wrote a quick script to solve the challenge. Given that the challenge\u0026rsquo;s description said the binary would have been run in May 2024, I bruteforced the timestamp from May to June:\ndata = open(\u0026#34;flag.enc\u0026#34;, \u0026#39;rb\u0026#39;).read() seed = 1740845724 def srand(s): global seed seed = s - 1 def rand(): global seed seed = (0x5851F42D4C957F2D * seed + 1) \u0026amp; 0xffffffffffffffff return seed \u0026gt;\u0026gt; 0x21 for t in range(1714521600, 1717200000): srand(t) msg = [] for c in data: rand_num = rand() msg.append(c ^ (rand_num % 0x7f)) msg = bytes(msg) if b\u0026#34;PWNME\u0026#34; in msg: print(msg) Running this will give us the flag: PWNME{4baf3723f62a15f22e86d57130bc40c3}\nC4 License #\rHolder\nMimirev #\rHolder\nSuper secure network #\rHolder\nMisc #\rDecode Runner #\rHolder\n","date":"2 March 2025","externalUrl":null,"permalink":"/posts/pwnme-ctf-2025-writeup/","section":"Posts","summary":"Overview #\rHere are some of the challenges that I solved during PwnMe CTF 2025:","title":"PwnMe CTF 2025 Writeup","type":"posts"},{"content":"","date":"2 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2 March 2025","externalUrl":null,"permalink":"/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"24 February 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]